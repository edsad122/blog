<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>内网穿透（P2P）原理与连接问题分析</title>
    <link href="/blog/2025/11/16/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%88P2P%EF%BC%89%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/"/>
    <url>/blog/2025/11/16/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%88P2P%EF%BC%89%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="报告：内网穿透（P2P）原理与连接问题分析"><a href="#报告：内网穿透（P2P）原理与连接问题分析" class="headerlink" title="报告：内网穿透（P2P）原理与连接问题分析"></a>报告：内网穿透（P2P）原理与连接问题分析</h2><img src="/blog/2025/11/16/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%EF%BC%88P2P%EF%BC%89%E5%8E%9F%E7%90%86%E4%B8%8E%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/ComfyUI_00096_.png" class="" title="可爱的远坂凛"><h3 id="第一部分：理论解释"><a href="#第一部分：理论解释" class="headerlink" title="第一部分：理论解释"></a>第一部分：理论解释</h3><p>本部分阐述实现内网穿透（NAT Traversal）所需的核心技术理论，包括P2P打洞、防火墙机制、中继模式以及ZeroTier所使用的虚拟叠加网络技术。</p><h4 id="1-1-核心困境：NAT-网络地址转换"><a href="#1-1-核心困境：NAT-网络地址转换" class="headerlink" title="1.1 核心困境：NAT (网络地址转换)"></a>1.1 核心困境：NAT (网络地址转换)</h4><ul><li><strong>问题：</strong> 大多数设备（如家中的电脑、手机）位于路由器（局域网）之后，它们拥有的是私有IP地址（如 <code>192.168.1.100</code>）。这些地址在公网上是不可路由的。</li><li><strong>NAT的角色：</strong> 路由器（网关）负责将所有出站的数据包的“源地址”从私有IP替换为路由器唯一的“公网IP”。</li><li><strong>结果：</strong> 局域网内的设备可以主动访问公网，但公网上的设备无法主动找到并连接到局域网内的特定设备。这就像一个只知道公寓大楼地址（公网IP），却不知道具体房号（私有IP+端口）的访客。</li></ul><h4 id="1-2-原理一：P2P“打洞”-Hole-Punching"><a href="#1-2-原理一：P2P“打洞”-Hole-Punching" class="headerlink" title="1.2 原理一：P2P“打洞” (Hole Punching)"></a>1.2 原理一：P2P“打洞” (Hole Punching)</h4><p>P2P打洞是解决NAT困境的首选方案，其核心是“欺骗”双方的防火墙来放行特定连接。</p><ol><li><p><strong>信令服务器 (Signaling Server &#x2F; Rendezvous Server)</strong></p><ul><li>拥有公网IP，所有人都能访问。</li><li><strong>步骤1（注册）：</strong> 设备A和设备B各自连接信令服务器。</li><li><strong>步骤2（记录）：</strong> 服务器并不知道A和B的私有IP，但它能看到A和B用来连接它的“公网代理地址”（即NAT映射的 <strong>公网IP+端口号</strong>）。服务器记录下这两个地址。</li><li><strong>步骤3（交换）：</strong> 服务器将B的“公网代理地址”告诉A，同时将A的“公网代理地址”告诉B。</li></ul></li><li><p><strong>状态检测防火墙 (Stateful Firewall)</strong></p><ul><li>这是P2P打洞得以实现的关键。现代路由器都使用“状态检测防火墙”。</li><li><strong>规则：</strong> 它不允许<strong>未知</strong>的入站包（陌生人来访）。但是，它会<strong>记忆</strong>所有“出站”包，并在短时间内（如60秒）<strong>允许其“回包”</strong>进入。</li><li><strong>“打洞”操作：</strong><ul><li>A和B在拿到对方地址后，<strong>几乎同时</strong>向对方的“公网代理地址”发送一个（UDP）包。</li><li>A向B发包时，在A的防火墙上“打”了一个洞，防火墙记下：“允许来自B的‘回包’。”</li><li>B向A发包时，在B的防火墙上“打”了一个洞，防火墙记下：“允许来自A的‘回包’。”</li><li><strong>结果：</strong> B的包到达A的防火墙，A的防火墙查表：“哦，这是我刚发给B的包的‘回包’！” -&gt; <strong>放行</strong>。A的包同理。</li><li>P2P直连通道建立。</li></ul></li></ul></li></ol><h4 id="1-3-原理二：中继模式-Relay-TURN"><a href="#1-3-原理二：中继模式-Relay-TURN" class="headerlink" title="1.3 原理二：中继模式 (Relay &#x2F; TURN)"></a>1.3 原理二：中继模式 (Relay &#x2F; TURN)</h4><ul><li><strong>问题：</strong> P2P打洞并非100%成功。在某些严格的网络（如“对称型NAT”）下，打洞会失败。</li><li><strong>兜底方案：</strong> 当P2P失败时，连接会“降级”为中继模式。</li><li><strong>流程：</strong> A把数据发给“信令服务器”（此时它兼任“中转站”），服务器再把数据转发给B。所有流量都通过服务器中转（<code>A -&gt; 服务器 -&gt; B</code>）。</li><li><strong>优缺点：</strong><ul><li><strong>优点：</strong> 保证连通性，成功率极高。</li><li><strong>缺点：</strong> 延迟高、速度慢，且极大消耗服务器的带宽。</li></ul></li></ul><h4 id="1-4-原理三：ZeroTier的“虚拟叠加网络”-Overlay-Network"><a href="#1-4-原理三：ZeroTier的“虚拟叠加网络”-Overlay-Network" class="headerlink" title="1.4 原理三：ZeroTier的“虚拟叠加网络” (Overlay Network)"></a>1.4 原理三：ZeroTier的“虚拟叠加网络” (Overlay Network)</h4><p>ZeroTier能实现“局域网效果”，是因为它在P2P（或中继）这条“物理路径”上，构建了一个“虚拟网络”。</p><ul><li><strong>虚拟网卡：</strong> ZeroTier会在您的设备上安装一个虚拟网卡，并分配一个固定的虚拟IP（如 <code>10.147.x.x</code>）。</li><li><strong>封装 (Encapsulation)：</strong><ol><li>当您 <code>ping 10.147.1.2</code>（B的虚拟IP）时，操作系统将这个包（<strong>内层包</strong>）交给ZeroTier的虚拟网卡。</li><li>ZeroTier软件将这个“内层包”原封不动地当作“货物”，塞进一个全新的UDP包（<strong>外层包</strong>）里。</li><li>这个“外层包”使用真实的公网IP作为源和目的地址（<code>A-Public-IP -&gt; B-Public-IP</code>）。</li><li>ZeroTier使用P2P打洞（原理1.2）或中继（原理1.3）技术，将这个“外层包”发送出去。</li></ol></li><li><strong>解封装：</strong> B的ZeroTier软件收到“外层包”，拆开信封，取出“内层包”，交给B的虚拟网卡。B的操作系统收到了一个来自 <code>10.147.1.1</code> 的ping，仿佛A和B真的在同一个局域网内。</li></ul><h4 id="1-5-原理四：P2P穿透的两道“防火墙”"><a href="#1-5-原理四：P2P穿透的两道“防火墙”" class="headerlink" title="1.5 原理四：P2P穿透的两道“防火墙”"></a>1.5 原理四：P2P穿透的两道“防火墙”</h4><p>一个数据包要成功，需要穿过两道关卡：</p><ol><li><strong>边界防火墙 (路由器&#x2F;NAT)：</strong><ul><li><strong>检查对象：</strong> <strong>外层包</strong>（公网IP）。</li><li><strong>通行方式：</strong> P2P打洞（利用“状态检测”）。</li></ul></li><li><strong>主机防火墙 (Windows&#x2F;Linux系统防火墙)：</strong><ul><li><strong>检查对象：</strong> <strong>内层包</strong>（虚拟IP，如 <code>10.147.x.x</code>）。</li><li><strong>通行方式：</strong> 操作系统自己的防火墙规则。如果您的Windows防火墙将ZeroTier网络设为“公用”，并禁止了ICMP(ping)入站，那么即便P2P打洞成功，数据包在解封装后也会被<strong>本机操作系统</strong>拦截。</li></ul></li></ol><hr><h3 id="第二部分：问题解析报告"><a href="#第二部分：问题解析报告" class="headerlink" title="第二部分：问题解析报告"></a>第二部分：问题解析报告</h3><p><strong>主题：</strong> 基于P2P内网穿透的虚拟局里网连接问题分析报告<br><strong>日期：</strong> 2025年11月16日</p><h4 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h4><p>本报告旨在分析一个由三台设备（两台固定主机、一台移动主机）和一台Planet（公网服务器）组成的ZeroTier虚拟局域网中，移动主机（设备C）在网络环境变化后，难以重新连接到固定主机（设备B）的问题。通过运用P2P打洞及NAT状态检测理论，本报告将解析该问题“连接失败”的根本原因，并阐明为何通过“反向Ping”操作（<code>B -&gt; C</code>）能有效解决此问题。</p><h4 id="2-问题场景复现"><a href="#2-问题场景复现" class="headerlink" title="2. 问题场景复现"></a>2. 问题场景复现</h4><ul><li><strong>参与节点：</strong><ul><li>设备A（固定主机，网络稳定）</li><li>设备B（固定主机，网络稳定）</li><li>设备C（移动主机，网络频繁变化，如 WiFi 切换至 4G）</li><li>Planet（公网服务器，用作信令与中继）</li></ul></li><li><strong>稳定状态：</strong> A、B、C 均与 Planet 连接，且 A-B-C 之间P2P直连稳定。</li><li><strong>触发条件：</strong> 设备C网络环境变更（如切换WiFi）。</li><li><strong>问题现象：</strong> 设备C可以重连 Planet，甚至能连上设备A，但无法与设备B建立P2P连接（<code>ping</code> 不通或延迟极高）。</li><li><strong>“奇效”操作：</strong> 通过 <code>C -&gt; A -&gt; B</code> 的链路，远程登录设备B，在设备B上主动 <code>ping</code> 设备C的虚拟IP。操作后，<code>C &lt;-&gt; B</code> 的P2P连接瞬间建立。</li></ul><h4 id="3-根本原因分析"><a href="#3-根本原因分析" class="headerlink" title="3. 根本原因分析"></a>3. 根本原因分析</h4><p>设备C切换网络，本质上是触发了两个关键事件：</p><ol><li><strong>公网代理地址变更：</strong> C的公网IP+端口号（NAT映射）改变了。</li><li><strong>NAT会话丢失：</strong> C在<strong>旧</strong>路由器防火墙上“打”的“洞”（状态检测表条目）立刻失效。</li></ol><p>这导致了以下两种连接失败：</p><ul><li><p><strong>失败情况一：地址同步延迟 (Stale Peer)</strong></p><ul><li>C 将新地址（<code>C-New-IP</code>）上报给 Planet。</li><li>Planet 通知B。但B可能由于延迟，<strong>还未收到更新</strong>。</li><li>B 仍然向 C 的<strong>旧地址</strong>（<code>C-Old-IP</code>）发送数据包，导致发送失败。</li></ul></li><li><p><strong>失败情况二：打洞协调失败 (Hole Punching Failed)</strong></p><ul><li>B <strong>已更新</strong> C 的新地址（<code>C-New-IP</code>）。</li><li>此时C向B发包（<code>C-New-IP -&gt; B-IP</code>）。这个包在C的<strong>新防火墙</strong>上打了个洞。</li><li>包到达B的防火墙。B的防火墙查表：“一个陌生的 <code>C-New-IP</code>，我没给它发过包。” -&gt; <strong>丢弃</strong>。</li><li>（同理，如果B先发包，也会被C的“冷”防火墙丢弃。）</li></ul></li></ul><p>P2P打洞的成功，依赖于双方“几乎同时”的发包动作。在移动场景下，网络切换导致这个“同时”协调机制被打破，双方的防火墙都将对方视为“陌生访问”而拒绝，导致P2P连接“卡住”。</p><h4 id="4-“反向Ping”操作的机理解析"><a href="#4-“反向Ping”操作的机理解析" class="headerlink" title="4. “反向Ping”操作的机理解析"></a>4. “反向Ping”操作的机理解析</h4><p><strong>本质是一次手动的、单向的“强制打洞”</strong>，完美地解决了上述“协调失败”的问题。</p><p><strong>操作分解：</strong> 在设备B上 <code>ping</code> 设备C的虚拟IP。</p><ol><li><strong>查询路由：</strong> B的ZeroTier客户端收到 <code>ping C-Virtual-IP</code> 的指令。</li><li><strong>获取地址：</strong> B向Planet查询，获取到C<strong>最新</strong>的公网代理地址（<code>C-New-IP</code>）。</li><li><strong>主动发包（打洞）：</strong> B的ZeroTier客户端立刻封装一个UDP包（外层包），<strong>主动</strong>向 <code>C-New-IP</code> 发送。</li><li><strong>防火墙开门：</strong> <strong>（最关键一步）</strong> B的防火墙在发包的瞬间，在“状态检测表”中记下：“我（<code>B-IP</code>）刚刚向 <code>C-New-IP</code> 发了一个包。在接下来60秒内，我<strong>允许</strong>任何来自 <code>C-New-IP</code> 的包进入，因为它应该是‘回包’。”</li><li><strong>连接建立：</strong><ul><li>与此同时，设备C的ZeroTier客户端（作为自愈机制的一部分）肯定也在锲而不舍地向B发包（<code>C-New-IP -&gt; B-IP</code>）。</li><li>C的这个包抵达了B的防火墙。</li><li>B的防火墙查表（见第4步），发现：“<code>C-New-IP</code>？哦，这是我刚联系过的地址，是‘回包’！”</li><li><strong>防火墙放行。</strong></li><li>P2P连接瞬间建立。</li></ul></li></ol><h4 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h4><p>移动设备网络切换导致的P2P连接失败，核心在于<strong>NAT会话状态的丢失</strong>以及<strong>P2P打洞协调的失败</strong>。</p><p>“反向Ping”操作，<strong>等同于手动强迫“固定主机（B）”向“移动主机（C）”的当前公网地址发起一次出站连接，从而单方面地在B的防火墙上预先“打”开了一个允许C进入的“洞”</strong>，这使得C的连接尝试得以成功，进而恢复了双向P2P通信。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>VLA论文阅读</title>
    <link href="/blog/2025/11/13/VLA/"/>
    <url>/blog/2025/11/13/VLA/</url>
    
    <content type="html"><![CDATA[<h1 id="AI机器人VLA模型论文阅读总结"><a href="#AI机器人VLA模型论文阅读总结" class="headerlink" title="AI机器人VLA模型论文阅读总结"></a><strong>AI机器人VLA模型论文阅读总结</strong></h1><p>本文档是对 Spec-VLA 和 FAST ($\pi_0$-FAST) 两篇核心论文的阅读、分析与思考总结。这两篇论文分别从“推理速度”和“训练效率&#x2F;高频控制”两个不同维度，对视觉-语言-动作（VLA）模型进行了关键优化。</p><h2 id="第一部分：Spec-VLA的阅读与思考（优化推理速度）"><a href="#第一部分：Spec-VLA的阅读与思考（优化推理速度）" class="headerlink" title="第一部分：Spec-VLA的阅读与思考（优化推理速度）"></a><strong>第一部分：Spec-VLA的阅读与思考（优化推理速度）</strong></h2><p>Spec-VLA: Speculative Decoding for Vision-Language-Action Models with Relaxed Acceptance</p><h3 id="1-核心问题：VLA模型的推理缓慢"><a href="#1-核心问题：VLA模型的推理缓慢" class="headerlink" title="1. 核心问题：VLA模型的推理缓慢"></a><strong>1. 核心问题：VLA模型的推理缓慢</strong></h3><ul><li><strong>问题所在：</strong> Spec-VLA 论文所基于的VLA模型（如 OpenVLA、RT-2）在推理（即机器人实际“决策”）时<strong>非常缓慢</strong>。  </li><li><strong>根本原因：</strong> 这些模型是**自回归（AR）**的。更糟糕的是，它们的“令牌”（Token）粒度非常细。  </li><li><strong>令牌定义：</strong> 在 OpenVLA 中，<strong>一个令牌不等于一个完整的动作</strong>。一个令牌仅代表一个7维动作向量中的<strong>一个维度</strong>（例如 $\Delta pos_x$）。  </li><li><strong>低效的串行过程：</strong> 为了预测一个时间步的完整动作（7维），模型必须<strong>依次</strong>（串行地）执行7次昂贵的前向传播，严重限制了机器人的实时反应能力：  <ol><li>[输入 图像&#x2F;指令] $\rightarrow$ 输出 $\Delta pos_x$ 令牌  </li><li>[输入 图像&#x2F;指令, $\Delta pos_x$] $\rightarrow$ 输出 $\Delta pos_y$ 令牌  </li><li>…  </li><li>[输入 图像&#x2F;指令, … $\Delta rot_z$] $\rightarrow$ 输出 gripper 令牌</li></ol></li></ul><h3 id="2-解决方案：推测解码（Speculative-Decoding-SD）"><a href="#2-解决方案：推测解码（Speculative-Decoding-SD）" class="headerlink" title="2. 解决方案：推测解码（Speculative Decoding, SD）"></a><strong>2. 解决方案：推测解码（Speculative Decoding, SD）</strong></h3><p>Spec-VLA 的核心思想是<strong>加速</strong>上述的串行解码过程，它是一个<strong>推理时</strong>的优化框架。</p><ul><li><strong>双模型架构：</strong>  <ol><li><strong>验证模型 (</strong>$M_V$<strong>)：</strong> 原始的、昂贵的 OpenVLA-7B 模型。  </li><li><strong>草稿模型 (</strong>$M_D$<strong>)：</strong> 一个小型的、高效的 Llama 解码器层，需要单独训练。</li></ol></li><li><strong>加速流程（老板与助理）：</strong>  <ol><li><strong>草稿（Drafting）：</strong> “助理”（$M_D$）廉价且快速地（串行）“猜测”出接下来 $k$ 个令牌（例如 $\Delta pos_x, \Delta pos_y, \Delta pos_z$）。  </li><li><strong>并行验证（Verification）：</strong> “老板”（$M_V$）利用Transformer的并行计算能力，<strong>一次前向传播</strong>就同时验证这 $k$ 个“草稿”令牌。  </li><li><strong>结果：</strong> 用1次昂贵的并行计算代替了k次昂贵的串行计算，实现了显著的推理加速。</li></ol></li></ul><h3 id="3-关键创新：宽松接受（Relaxed-Acceptance）"><a href="#3-关键创新：宽松接受（Relaxed-Acceptance）" class="headerlink" title="3. 关键创新：宽松接受（Relaxed Acceptance）"></a><strong>3. 关键创新：宽松接受（Relaxed Acceptance）</strong></h3><ul><li><strong>新问题：</strong> 机器人动作预测很难，“助理” $M_D$ 猜的草稿经常“不完全正确”，导致接受率低，加速效果差。  </li><li><strong>传统SD：</strong> 必须完全匹配（$\hat{a}_i =&#x3D; a_i$）才接受。  </li><li><strong>Spec-VLA 的洞察：</strong> 在VLA中，令牌代表的是离散化的物理“箱子”。令牌ID 100 和 101 在物理上是<strong>极其接近</strong>的。  </li><li><strong>宽松接受：</strong> Spec-VLA 允许草稿令牌 $\hat{a}_i$ 与验证令牌 $a_i$ 之间存在一个小的“距离阈值 <em>r</em>”。只要草稿“足够接近”正确答案（例如物理距离在 $r$ 范围内），就被接受。  </li><li><strong>效果：</strong> 接受率大幅提高，在不牺牲任务成功率的前提下，实现了高达<strong>1.42倍</strong>的加速。</li></ul><h3 id="4-进阶技术：动态草稿树（Dynamic-Draft-Tree）"><a href="#4-进阶技术：动态草稿树（Dynamic-Draft-Tree）" class="headerlink" title="4. 进阶技术：动态草稿树（Dynamic Draft Tree）"></a><strong>4. 进阶技术：动态草稿树（Dynamic Draft Tree）</strong></h3><ul><li>为了进一步提高接受率，Spec-VLA 还使用了“动态草稿树”解码。  </li><li>当“助理” $M_D$ 对下一步预测不确定时（例如，40%认为是令牌A，35%认为是令牌B），它<strong>不会只赌一个</strong>。  </li><li>它会同时生成<strong>多个分支</strong>（一个“树”），然后让“老板” $M_V$ 一次性并行验证<strong>所有</strong>的分支，大大增加了“猜对”的概率。</li></ul><h2 id="第二部分：FAST-pi-0-FAST的阅读与思考（优化训练与高频控制）"><a href="#第二部分：FAST-pi-0-FAST的阅读与思考（优化训练与高频控制）" class="headerlink" title="第二部分：FAST &#x2F; $\pi_0$-FAST的阅读与思考（优化训练与高频控制）"></a><strong>第二部分：FAST &#x2F; $\pi_0$-FAST的阅读与思考（优化训练与高频控制）</strong></h2><p>FAST: Efficient Action Tokenization for Vision-Language-Action Models</p><h3 id="1-核心问题：VLA模型的数据高频信息密度低与训练效率低下"><a href="#1-核心问题：VLA模型的数据高频信息密度低与训练效率低下" class="headerlink" title="1. 核心问题：VLA模型的数据高频信息密度低与训练效率低下"></a><strong>1. 核心问题：VLA模型的数据高频信息密度低与训练效率低下</strong></h3><p>FAST 解决的是一个与 Spec-VLA <strong>完全不同</strong>的问题。</p><ol><li><strong>高频控制失灵：</strong> 传统VLA（如 OpenVLA）在处理高频、灵巧的任务（如50Hz折叠T恤）时<strong>完全失败</strong>。  <ul><li><strong>原因：</strong> 在50Hz下，时间 $t$ 和 $t+1$ 的动作几乎完全相同。这导致“下一个令牌”几乎不包含新信息，模型的“学习信号”非常弱，导致训练失败。</li></ul></li><li><strong>训练效率低下：</strong> 当时的SOTA（最先进）模型（如 $\pi_0$-Diffusion）虽然能处理高频任务，但它们是扩散模型，<strong>训练成本极高</strong>（论文中提到 $\pi_0$-FAST 训练速度快5倍）。</li></ol><h3 id="2-解决方案：一种全新的令牌化方案（FAST）"><a href="#2-解决方案：一种全新的令牌化方案（FAST）" class="headerlink" title="2. 解决方案：一种全新的令牌化方案（FAST）"></a><strong>2. 解决方案：一种全新的令牌化方案（FAST）</strong></h3><p>FAST 的核心思想是：<strong>如果“下一个令牌”没有信息量，那就重新定义“令牌”！</strong></p><ul><li><strong>令牌定义（根本不同）：</strong>  <ul><li>OpenVLA 令牌 = 1个时间步的1个维度（例如 $\Delta x$）。  </li><li>FAST 令牌 = <strong>一整段动作块</strong>（例如1秒）的<strong>压缩频率信息</strong>的一部分。</li></ul></li><li><strong>FAST 令牌化器（一个算法，而非NN）：</strong>  <ol><li><strong>获取信号：</strong> 取1秒钟的连续动作数据（一个“Chunk”）。  </li><li><strong>DCT变换 (核心)：</strong> 使用<strong>离散余弦变换</strong>（JPEG图像压缩同款技术）将时域信号转换为<strong>频域</strong>信号。此时，信号的大部分信息被压缩到少数几个<strong>低频系数</strong>上。  </li><li><strong>量化&#x2F;压缩：</strong> 通过缩放和四舍五入，使系数矩阵变得稀疏（大部分为0）。  </li><li><strong>BPE编码 (唯一“训练”部分)：</strong> 使用<strong>字节对编码</strong>（GPT分词器同款技术）对这些稀疏系数进行<strong>无损压缩</strong>。BPE的“训练”目标是<strong>最大化压缩率</strong>，它学习如何用最少的BPE符号来表示这些系数。</li></ol></li><li><strong>$\pi_0$-FAST 模型：</strong>  <ul><li>这是一个标准的<strong>自回归（AR）模型</strong>（骨干是 PaliGemma-3B）。  </li><li>它被训练来预测<strong>下一个 FAST（BPE）令牌</strong>。  </li><li>由于 FAST 令牌代表的是高信息密度的“频率分量”，因此“下一个令牌预测”任务变得有意义且高效。</li></ul></li></ul><h3 id="3-总结：FAST的优势"><a href="#3-总结：FAST的优势" class="headerlink" title="3. 总结：FAST的优势"></a><strong>3. 总结：FAST的优势</strong></h3><p>$\pi_0$-FAST 是一个自回归模型，它通过预测 FAST 令牌（即动作块的压缩频率分量），成功解决了高频控制任务，同时达到了与SOTA扩散模型相当的性能，但<strong>训练速度</strong>快了5倍。</p><h2 id="第三部分：关于Transformer的理解与思考"><a href="#第三部分：关于Transformer的理解与思考" class="headerlink" title="第三部分：关于Transformer的理解与思考"></a><strong>第三部分：关于Transformer的理解与思考</strong></h2><p>在研究这两篇论文时，对Transformer的底层工作机制有了更清晰的理解，这对于区分二者的工作原理至关重要。</p><h3 id="1-“令牌”（Token-）与-“嵌入”（Embedding）"><a href="#1-“令牌”（Token-）与-“嵌入”（Embedding）" class="headerlink" title="1. “令牌”（Token**）与**“嵌入”（Embedding）"></a><strong>1. “令牌”（Token**）与**“嵌入”（Embedding）</strong></h3><ul><li><strong>令牌（Token）：</strong> 是一个<strong>整数ID</strong>，来自一个预先确定的“词汇表”。例如，OpenVLA 的 $\Delta pos_x$ 维度有256个“箱子”，令牌就是 0 到 255 之间的整数。$\pi_0$-FAST 的BPE词汇表有1024个符号，令牌就是 0 到 1023 之间的整数。  </li><li><strong>嵌入（Embedding）：</strong> 是一个<strong>高维特征向量</strong>（例如4096维）。它存储在一个巨大的“查询表”（nn.Embedding）中。令牌ID就是这个表的<strong>索引</strong>。</li></ul><h3 id="2-训练目标（Loss）不是“Embedding差”"><a href="#2-训练目标（Loss）不是“Embedding差”" class="headerlink" title="2. 训练目标（Loss）不是“Embedding差”"></a><strong>2. 训练目标（Loss）不是“Embedding差”</strong></h3><ul><li>Transformer的训练目标<strong>不是</strong>预测一个高维Embedding向量然后计算L2距离（这是回归问题）。  </li><li>它的训练目标是<strong>预测下一个令牌ID</strong>（这是一个<strong>分类问题</strong>）。  </li><li><strong>流程：</strong>  <ol><li>Decoder主体输出一个高维“思考总结”向量（例如4096维）。  </li><li>一个最终的线性层（LM Head）将其投影到一个巨大的“Logits”向量上，维度等于<strong>词汇表大小</strong>（例如50,000维）。  </li><li>Logits通过 Softmax 转换为一个<strong>概率分布</strong>（例如，模型认为ID 191 有95%的概率是答案）。  </li><li>**交叉熵损失（Cross-Entropy Loss）**被用来计算这个“概率分布”和“真实令牌ID（191）”之间的差距。</li></ol></li><li>这个Loss的梯度会反向传播，更新<strong>包括Embedding层在内</strong>的所有模型参数。</li></ul><h3 id="3-Transformer的“并行魔法”：因果掩码"><a href="#3-Transformer的“并行魔法”：因果掩码" class="headerlink" title="3. Transformer的“并行魔法”：因果掩码"></a><strong>3. Transformer的“并行魔法”：因果掩码</strong></h3><ul><li><strong>标准AR推理（慢）：</strong> 是一个<strong>串行</strong>循环，必须输入[T1] $\rightarrow$ 得到T2，然后输入[T1, T2] $\rightarrow$ 得到T3。  </li><li><strong>Spec-VLA的并行验证（快）：</strong> 它利用了Transformer在<strong>训练时</strong>的并行机制。  </li><li><strong>工作原理：</strong>  <ol><li>Spec-VLA 将 [\hat{a}_1, \hat{a}_2, \hat{a}_3] <strong>一次性</strong>输入到 OpenVLA 模型中。  </li><li>模型内部的<strong>因果掩码（Causal Mask）</strong>（或称“前瞻掩码”）生效。  </li><li>这个掩码确保了：  <ul><li>在计算<strong>位置1</strong>的输出（$a_1$）时，模型只能看到 &lt;START&gt;。  </li><li>在计算<strong>位置2</strong>的A输出（$a_2$）时，模型只能看到 $\hat{a}_1$。  </li><li>在计算<strong>位置3</strong>的输出（$a_3$）时，模型只能看到 $\hat{a}_1$ 和 $\hat{a}_2$。</li></ul></li><li>因此，模型在<strong>一次前向传播</strong>中，就<strong>并行</strong>地计算出了所有位置的“正确”输出 [a_1, a_2, a_3]，这正是Spec-VLA加速的核心。</li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用Java实现汇编器+链接器</title>
    <link href="/blog/2024/01/11/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%B1%87%E7%BC%96%E5%99%A8-%E9%93%BE%E6%8E%A5%E5%99%A8/"/>
    <url>/blog/2024/01/11/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%B1%87%E7%BC%96%E5%99%A8-%E9%93%BE%E6%8E%A5%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="设计功能描述"><a href="#设计功能描述" class="headerlink" title="设计功能描述"></a>设计功能描述</h1><p>使用Java编写的将MiniSys汇编程序转换到 Minisys 体系机器码的汇编器，同时兼具链接功能。</p><img src="/blog/2024/01/11/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%B1%87%E7%BC%96%E5%99%A8-%E9%93%BE%E6%8E%A5%E5%99%A8/out.png" class="" title="图文无关，累了跑跑图🤓"><h2 id="模块功能"><a href="#模块功能" class="headerlink" title="模块功能"></a>模块功能</h2><ul><li>main.java：程序入口，实现命令行，-l表示是否与bios，中断程序链接。例： <em>$ java -jar minisys-java.jar <in_file> <out_dir> -l</em></li><li>Assembler.java：实现对数据段、指令段的汇编，先对指令进行宏展开，将指令与label分离并储存label以及其对应的地址，遍历所有指令进行汇编，最后输出AsmProgram（包含了处理后的数据段、指令段数据）。</li><li>MiniInstructions.java：实现57条指令，保存其相应的正则格式，调用toBinary方法即可实现指令转二进制。</li><li>Converter.java：将输入的AsmProgram转为相应的Coe文件，也实现了将数据段、指令段的Coe文件合并生成可以直接在开放板上运行的serial。</li><li>Linker.java：根据MiniSys的MEM布局（BIOS 区域、用户程序区域、中断处理程序入口、中断处理程序）对二进制数据实现内存的布局、地址的重定位。</li><li>MacroExpansionRules：实现宏指令，可以将push、pop、jg、jge、jl、jle、move宏指令转为常用指令。</li><li>Instruction.java：实现了指令类的底层逻辑，为了实现对57条指令的兼容，包含了自定义正则、指令componentList自定义、toBinary自定义（每种指令的构成、正则格式都是不同的，这样实现简单易用）。</li><li>Register.java：实现了寄存器的转换，可以对32个通用寄存器进行映射。</li><li>Utils：通用工具类，实现了label转二进制（Assember里已经保存了label的数据），变量转二进制以及各种通用的十六转二进制，十进制转二进制，计算偏移地址，获取数据类型大小等工具。</li></ul><h1 id="设计的主要特色"><a href="#设计的主要特色" class="headerlink" title="设计的主要特色"></a>设计的主要特色</h1><h2 id="宏指令支持"><a href="#宏指令支持" class="headerlink" title="宏指令支持"></a>宏指令支持</h2><p>通过对宏指令转换为MiniSys支持的57条常用指令，实现对push、pop、jg、jge、jl、jle、move宏指令的支持。</p><h2 id="内存的布局、地址的重定位"><a href="#内存的布局、地址的重定位" class="headerlink" title="内存的布局、地址的重定位"></a>内存的布局、地址的重定位</h2><p>链接器根据MiniSys的MEM布局（BIOS 区域、用户程序区域、中断处理程序入口、中断处理程序）对二进制数据实现内存的布局、地址的重定位，并生成可以直接在开放板上使用的serial文件。</p><h2 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h2><p>在Instruction类实现中，由于正则、componentList、toBinary都可以自定义。因此，仅需在MinisysInstructions类中加入新指令对应的正则、指令格式、二进制转译规则，即可实现对新指令的支持。</p><h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><img src="/blog/2024/01/11/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%B1%87%E7%BC%96%E5%99%A8-%E9%93%BE%E6%8E%A5%E5%99%A8/asm.png" class="" title="MiniAsm项目框架"><p>汇编器的结构如图所示：Assembler接收一个包含汇编代码的文件（.asm格式）。首先，进行宏指令扩展，并在此过程中处理标签（label），将处理后的结果存储在TextSegLabel中。随后，逐行处理指令，并将处理后的信息整合到AsmProgram中。AsmProgram包括数据段（DataSeg）和指令段（TextSeg）。数据段保存了所有变量的名称、类型以及相应的值，而指令段保存了所有指令的详细信息。</p><h1 id="设计与特色概述"><a href="#设计与特色概述" class="headerlink" title="设计与特色概述"></a>设计与特色概述</h1><h2 id="指令类的底层逻辑：Instruction-java"><a href="#指令类的底层逻辑：Instruction-java" class="headerlink" title="指令类的底层逻辑：Instruction.java"></a>指令类的底层逻辑：Instruction.java</h2><img src="/blog/2024/01/11/%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E6%B1%87%E7%BC%96%E5%99%A8-%E9%93%BE%E6%8E%A5%E5%99%A8/Ins.png" class="" title="指令格式"><p>该类涵盖了当前指令的各个方面，包括指令类型、描述、指令名称、指令正则模式，以及构成列表（List&lt;InstructionComponent&gt;）。在这个上下文中，InstructionComponent用于定义指令的构成。具体而言，MIPS指令在图示中规定了其格式和含义，而InstructionComponent则指明了从lBit到rBit位置的二进制数据的类型type。toBinary方法定义了如何生成二进制val值，若不需要生成，则为null。每个指令包含多个InstructionComponent，如图中所示，其中第一个和最后一个是固定的，而中间的三个通过toBinary方法生成相应的二进制val值。举例来说，通过正则表达式解析输入的字符串，然后提取值并将其转换为二进制，最后填入相应的位置。这种设计能够有效地实现指令的解析和二进制表示，使其在汇编器中发挥作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toBinary</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (InstructionComponent component : components) &#123;<br>        <span class="hljs-keyword">if</span> (component.getVal().trim().isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;尝试将不完整的指令转为2或16进制。&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> components.stream().map(InstructionComponent::getVal).reduce(String::concat).orElse(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，实现了toBinary方法，其主要功能是提取之前InstructionComponent中存储的已转换为二进制的val值，并将它们合并成一个二进制流。值得注意的是，此处的toBinary方法与前文中Component中的toBinary方法并不相同。这里的toBinary方法专注于将Component中通过toBinary生成的二进制值（如果toBinary为null，则直接使用val）整合成一个二进制流。</p><h2 id="通用指令的实现：MiniInstructions-java"><a href="#通用指令的实现：MiniInstructions-java" class="headerlink" title="通用指令的实现：MiniInstructions.java"></a>通用指令的实现：MiniInstructions.java</h2><p>该类为Instruction的上层类，构建了57条MIPS通用指令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">newInstruction(<span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;按字加法&quot;</span>, <span class="hljs-string">&quot;(rd)←(rs)+(rt)&quot;</span>, paramPattern(<span class="hljs-number">3</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>[]&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">31</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;op&quot;</span>, <span class="hljs-literal">null</span>, InstructionComponentType.FIXED, <span class="hljs-string">&quot;000000&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;rs&quot;</span>, m -&gt; Register.regToBin(m.group(<span class="hljs-number">2</span>)), InstructionComponentType.REG, <span class="hljs-string">&quot;&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;rt&quot;</span>, m -&gt; Register.regToBin(m.group(<span class="hljs-number">3</span>)), InstructionComponentType.REG, <span class="hljs-string">&quot;&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">15</span>, <span class="hljs-number">11</span>, <span class="hljs-string">&quot;rd&quot;</span>, m -&gt; Register.regToBin(m.group(<span class="hljs-number">1</span>)), InstructionComponentType.REG, <span class="hljs-string">&quot;&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&quot;shamt&quot;</span>, <span class="hljs-literal">null</span>, InstructionComponentType.FIXED, <span class="hljs-string">&quot;00000&quot;</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;func&quot;</span>, <span class="hljs-literal">null</span>, InstructionComponentType.FIXED, <span class="hljs-string">&quot;100000&quot;</span>)<br></code></pre></td></tr></table></figure><p>根据上图所示，通过newInstruction方法构建新指令。此方法接受指令名称、指令描述、指令正则和指令构成列表等参数，其中指令构成列表的格式按照MIPS指令的规范输入。这使得我们能够轻松地构建新的指令。值得注意的是，toBinary方法，在已经输入了val或者type为FIXED的情况下会为null。而在其他情况下，它定义了如何处理指令正则匹配后的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">31</span>, <span class="hljs-number">26</span>, <span class="hljs-string">&quot;op&quot;</span>, <span class="hljs-literal">null</span>, InstructionComponentType.FIXED, <span class="hljs-string">&quot;100100&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">25</span>, <span class="hljs-number">21</span>, <span class="hljs-string">&quot;rs&quot;</span>, m -&gt; Register.regToBin(m.group(<span class="hljs-number">3</span>)), InstructionComponentType.REG, <span class="hljs-string">&quot;&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">20</span>, <span class="hljs-number">16</span>, <span class="hljs-string">&quot;rt&quot;</span>, m -&gt; Register.regToBin(m.group(<span class="hljs-number">1</span>)), InstructionComponentType.REG, <span class="hljs-string">&quot;&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InstructionComponent</span>(<span class="hljs-number">15</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;offset&quot;</span>, m -&gt; Utils.varToAddrBin(m.group(<span class="hljs-number">2</span>), <span class="hljs-number">16</span>, <span class="hljs-literal">true</span>), InstructionComponentType.OFFSET, <span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>例如，在处理add指令时，正则匹配后的参数为寄存器，因此，我们需要对matcher m的group进行regToBin的操作。如果是匹配后是offset的参数，则需要varToAddrBin或labelToBin，immediate则为literalToBin。同理，可以得到其他56条指令。</p><h2 id="Register-java：寄存器的实现"><a href="#Register-java：寄存器的实现" class="headerlink" title="Register.java：寄存器的实现"></a>Register.java：寄存器的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">regToBin</span><span class="hljs-params">(String reg)</span> &#123;<br>        reg = reg.replace(<span class="hljs-string">&quot;$&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).trim();<br>        <span class="hljs-type">int</span> regNumber;<br>        <span class="hljs-keyword">if</span> (reg.matches(<span class="hljs-string">&quot;\\d+&quot;</span>)) &#123;<br>            regNumber = Integer.parseInt(reg);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            regNumber = indexOfRegister(reg);<br>        &#125;<br>        <span class="hljs-keyword">return</span> Utils.decToBin(regNumber, <span class="hljs-number">5</span>,<span class="hljs-literal">false</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>实现寄存器功能并不复杂。通过接收输入的寄存器名称（reg），我们可以轻松找到相应的寄存器索引（Index），然后通过decToBin方法将其转换为二进制表示，最终进行输出。</p><h2 id="MacroExpansionRules-java：宏指令的实现"><a href="#MacroExpansionRules-java：宏指令的实现" class="headerlink" title="MacroExpansionRules.java：宏指令的实现"></a>MacroExpansionRules.java：宏指令的实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">expansionRules.put(<span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MacroExpansionRule</span>(<span class="hljs-string">&quot;^push\\s+(\\$\\w&#123;1,2&#125;)$&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;addi $sp, $sp, -4&quot;</span>, <span class="hljs-string">&quot;sw $&#123;RegExp.$1&#125;, 0($sp)&quot;</span>&#125;));<br>expansionRules.put(<span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MacroExpansionRule</span>(<span class="hljs-string">&quot;^pop\\s+(\\$\\w&#123;1,2&#125;)$&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;lw $&#123;RegExp.$1&#125;, 0($sp)&quot;</span>, <span class="hljs-string">&quot;addi $sp, $sp, 4&quot;</span>&#125;));<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">replaceGroups</span><span class="hljs-params">(Matcher matcher, String input)</span> &#123;<br>            <span class="hljs-comment">// Check for presence of $&#123;RegExp.$3&#125;, $&#123;RegExp.$2&#125;, $&#123;RegExp.$1&#125; before replacing</span><br>            <span class="hljs-keyword">if</span> (input.contains(<span class="hljs-string">&quot;$&#123;RegExp.$3&#125;&quot;</span>)) &#123;<br>                input = input.replace(<span class="hljs-string">&quot;$&#123;RegExp.$3&#125;&quot;</span>, getGroup(matcher, <span class="hljs-number">3</span>));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (input.contains(<span class="hljs-string">&quot;$&#123;RegExp.$2&#125;&quot;</span>)) &#123;<br>                input = input.replace(<span class="hljs-string">&quot;$&#123;RegExp.$2&#125;&quot;</span>, getGroup(matcher, <span class="hljs-number">2</span>));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (input.contains(<span class="hljs-string">&quot;$&#123;RegExp.$1&#125;&quot;</span>)) &#123;<br>                input = input.replace(<span class="hljs-string">&quot;$&#123;RegExp.$1&#125;&quot;</span>, getGroup(matcher, <span class="hljs-number">1</span>));<br>            &#125;<br>            <span class="hljs-keyword">return</span> input;<br>        &#125;<br></code></pre></td></tr></table></figure><p>宏指令的展开过程首先涉及对相关指令的参数获取。在获取到这些参数之后，通过对这些参数的合成操作，生成新的指令序列，这些指令即为通用的MIPS指令。最终，将这一新生成的指令序列返回，这相当于将原始宏指令在语义上替换为相应的MIPS通用指令。</p><h2 id="Assembler-java：汇编功能的主要模块"><a href="#Assembler-java：汇编功能的主要模块" class="headerlink" title="Assembler.java：汇编功能的主要模块"></a>Assembler.java：汇编功能的主要模块</h2><p>该模块主要涉及两个关键方面的处理，即数据段和指令段，这两者在该模块中进行详细处理。</p><h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">startAddr</span> <span class="hljs-operator">=</span> asm.get(<span class="hljs-number">0</span>).split(<span class="hljs-string">&quot;\\s+&quot;</span>).length != <span class="hljs-number">1</span> ? asm.get(<span class="hljs-number">0</span>).split(<span class="hljs-string">&quot;\\s+&quot;</span>)[<span class="hljs-number">1</span>] : <span class="hljs-string">&quot;0&quot;</span>;<br><span class="hljs-keyword">if</span> (asm.get(<span class="hljs-number">0</span>).split(<span class="hljs-string">&quot;\\s+&quot;</span>).length &gt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;数据段首声明非法&quot;</span>);<br>&#125;<br><span class="hljs-comment">//初始化</span><br>List&lt;DataSegVarComp&gt; comps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>vars = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> addr;<br><span class="hljs-keyword">if</span>(startAddr.startsWith(<span class="hljs-string">&quot;0x&quot;</span>))&#123;<br>    addr=Integer.parseInt(startAddr.substring(<span class="hljs-number">2</span>),<span class="hljs-number">16</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    addr=Integer.parseInt(startAddr);<br>&#125;<br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextAddr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(addr);<br></code></pre></td></tr></table></figure><p>首先，我们考虑数据段。数据段的处理分为三个状态：初始化、新增变量、变量中继。在初始化状态中，首先判断文件的第一行是否包含.data，然后获取起始地址startAddr和下一个地址nextAddr。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Matcher</span> <span class="hljs-variable">varStartMatcher</span> <span class="hljs-operator">=</span> VAR_START_PATTERN.matcher(asm.get(i));<br><span class="hljs-type">Matcher</span> <span class="hljs-variable">varContdMatcher</span> <span class="hljs-operator">=</span> VAR_CONTD_PATTERN.matcher(asm.get(i));<br></code></pre></td></tr></table></figure><p>如上图所示，通过正则表达式判断当前状态是新增变量还是变量中继状态。在新增变量状态中，即处理最初的变量声明，将上一次获取的信息存入变量集合vars中（如果上一次没有信息，则跳过）。然后，创建一个DataSegVar对象，将正则匹配得到的参数填入name和type字段，而最后一个参数value由于asm文件中可能使用逗号分隔多个变量，需要使用parseInitValue方法来处理。parseInitValue方法能够解析并存储数据到DataSegVar中。下图即为parseInitValue的调用，输入type和Matcher的最后一个参数，获得到的数据将其存入DataSegVar中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">parseInitValue(type, varStartMatcher.group(<span class="hljs-number">3</span>)).forEach(val -&gt; &#123;<br>    finalComps.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSegVarComp</span>(type, val.trim()));<br>    nextAddr.addAndGet(size * (Objects.equals(type, <span class="hljs-string">&quot;ascii&quot;</span>) ? val.length() : <span class="hljs-number">1</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">parseInitValue</span><span class="hljs-params">(String type, String init)</span> &#123;<br>        <span class="hljs-keyword">assert</span> !(!Objects.equals(type, <span class="hljs-string">&quot;ascii&quot;</span>) &amp;&amp; init.contains(<span class="hljs-string">&quot;\&quot;&quot;</span>)) : <span class="hljs-string">&quot;字符串型数据只能使用.ascii类型&quot;</span>;<br>        init = init.trim();<br>        <span class="hljs-keyword">assert</span> init.charAt(<span class="hljs-number">0</span>) != <span class="hljs-string">&#x27;,&#x27;</span> &amp;&amp; init.charAt(init.length() - <span class="hljs-number">1</span>) != <span class="hljs-string">&#x27;,&#x27;</span> : <span class="hljs-string">&quot;数据初始化值头或尾有非法逗号&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (!Objects.equals(type, <span class="hljs-string">&quot;ascii&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> Stream.of(init.split(<span class="hljs-string">&quot;\\s*,&quot;</span>)).toList();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">inQuote</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">nextEscape</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            List&lt;String&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>            <span class="hljs-type">char</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; init.length(); i++) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> init.charAt(i);<br>                <span class="hljs-keyword">if</span> (!inQuote &amp;&amp; Character.isWhitespace(ch)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;&quot;&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (nextEscape) &#123;<br>                        <span class="hljs-keyword">assert</span> inQuote : <span class="hljs-string">&quot;有非法字符出现在引号以外&quot;</span>;<br>                        buf.append(<span class="hljs-string">&#x27;&quot;&#x27;</span>);<br>                        nextEscape = <span class="hljs-literal">false</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        inQuote = !inQuote;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;\\&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">assert</span> inQuote : <span class="hljs-string">&quot;有非法字符出现在引号以外&quot;</span>;<br>                    <span class="hljs-keyword">if</span> (nextEscape) &#123;<br>                        buf.append(<span class="hljs-string">&#x27;\\&#x27;</span>);<br>                        nextEscape = <span class="hljs-literal">false</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        nextEscape = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;,&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (inQuote) &#123;<br>                        buf.append(<span class="hljs-string">&#x27;,&#x27;</span>); <span class="hljs-comment">// 引号内逗号可不escape</span><br>                        nextEscape = <span class="hljs-literal">false</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">assert</span> prev != <span class="hljs-string">&#x27;,&#x27;</span> : <span class="hljs-string">&quot;数据初始化值存在连续的逗号分隔&quot;</span>;<br>                        res.add(buf.toString());<br>                        buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">assert</span> inQuote : <span class="hljs-string">&quot;有非法字符出现在引号以外&quot;</span>;<br>                    <span class="hljs-keyword">if</span> (nextEscape) &#123;<br>                        buf.append(StringProcessor.unraw(ch));<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        buf.append(ch);<br>                    &#125;<br>                    nextEscape = <span class="hljs-literal">false</span>;<br>                &#125;<br>                prev = ch;<br>            &#125;<br>            res.add(buf.toString());<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>以上为parseInitValue的具体实现，此函数接受两个参数：“type”和“init”，type是变量类型，init是变量的初始值。 “parseInitValue”函数首先声明，如果变量类型不是“ascii”，则初始值不应包含双引号字符。判断初始值是否以逗号开头或结尾。 如果变量类型不是“ascii”，则函数会用逗号分隔初始值，并返回一个修剪后的值数组。 如果变量类型为“ascii”，则函数将进入更复杂的解析过程。 它初始化几个变量以跟踪解析状态，包括它当前是否在带引号的字符串（“inQuote”）内，是否应转义下一个字符（“nextEscape”）、结果数组（“res”）、当前字符串的缓冲区（“buf”）和前一个字符的缓冲区。 然后，函数在初始值中的每个字符上进入一个循环。根据当前字符和解析状态，它会更新状态变量并将字符添加到缓冲区或结果数组中。 该函数使用“assert”函数来确保初始值的语法正确，如果遇到非法字符或序列，则会引发错误。</p><p>举例说明：如果输入的是<code> a: .ascii &quot;hello&quot;,&quot;world&quot;</code> 则name为a，type为ascii，第3个参数会交给parseInitValue处理成包含”hello”、”world”的List。</p><p>变量中继状态处理除了不会新建一个DataSegVar与变量开始状态基本一致。</p><h2 id="指令段"><a href="#指令段" class="headerlink" title="指令段"></a>指令段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">expandMacros</span><span class="hljs-params">(List&lt;String&gt; asm, List&lt;Integer&gt; lineno)</span> &#123;<br>        List&lt;String&gt; expandedAsm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(asm);<br>        String[] macros = MacroExpansionRules.expansionRules.keySet().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bias</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; asm.size(); i++) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> asm.get(i);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">labelPreserve</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">Pattern</span> <span class="hljs-variable">labelPattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^(\\w+:)\\s*([\\w\\s$]+)$&quot;</span>);<br>            <span class="hljs-type">Matcher</span> <span class="hljs-variable">lableMatcher</span> <span class="hljs-operator">=</span> labelPattern.matcher(v);<br>            <span class="hljs-keyword">if</span> (lableMatcher.matches()) &#123;<br>                labelPreserve = lableMatcher.group(<span class="hljs-number">1</span>);<br>                v = lableMatcher.group(<span class="hljs-number">2</span>).trim();<br>            &#125;<br>            <span class="hljs-keyword">for</span> (String macro : macros) &#123;<br>                <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> MacroExpansionRules.expansionRules.get(macro).pattern;<br>                <span class="hljs-type">Matcher</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pattern.matcher(v);<br>                <span class="hljs-keyword">if</span> (m.matches()) &#123;<br>                    String[] replacer = MacroExpansionRules.expansionRules.get(macro).replace(m);<br>                    replacer[<span class="hljs-number">0</span>] = labelPreserve + <span class="hljs-string">&quot; &quot;</span> + replacer[<span class="hljs-number">0</span>];<br>                    expandedAsm.remove(i + bias);<br>                    expandedAsm.addAll(i + bias, Arrays.asList(replacer));<br><br>                    lineno.remove(i + bias);<br>                    lineno.addAll(i + bias, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Collections.nCopies(replacer.length, lineno.get(i + bias))));<br>                    bias += replacer.length - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> expandedAsm;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在开始指令段的处理之前需要对其进行宏指令扩展，如上图所示，<code>expandMacros</code>函数用于在汇编语言源代码中扩展宏。该函数接收两个参数：<code>asm</code>（汇编语言指令的数组）和<code>lineno</code>（对应于指令的行号数组）。</p><p>函数开始时，创建了<code>asm</code>数组的副本，并初始化了几个变量，包括<code>macros</code>（从<code>expansionRules</code>对象中获取的键的数组），以及<code>bias</code>（用于跟踪由于替换指令为扩展宏而引起的偏移）。</p><p>然后，函数遍历<code>asm</code>数组中的每个指令。对于每个指令，它检查是否匹配<code>LabelPattern</code>正则表达式。如果匹配，它会保留标签部分并修剪指令的其余部分。</p><p>接下来，函数检查指令是否匹配<code>expansionRules</code>对象中任何宏的模式。如果匹配，它获取匹配宏的替换器，将保留的标签添加到替换器中的第一条指令前，然后在<code>asm</code>数组中用扩展宏替换原始指令。它还更新<code>lineno</code>数组以反映宏扩展后的新行号，并更新<code>bias</code>以考虑数组长度的变化。</p><p>最后，函数返回所有宏都已扩展的<code>asm</code>数组。前面宏指令已经介绍过，这里调用replace函数，并传入正则匹配后的参数即可返回替换的指令。再将这些处理后的指令插入到原指令中并更新lineno。</p><p>处理宏指令后正式加入指令段处理，和数据段的处理相同，先判断是否存在格式问题，再初始化开始地址startAddr和下一个地址nextAddr。与之不同的是，需要对label进行预处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (labelMatcher.matches()) &#123;<br>    labels.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextSegLabel</span>(labelMatcher.group(<span class="hljs-number">1</span>), insLineno, Utils.getOffsetAddr(startAddr, (insLineno - <span class="hljs-number">1</span>) * Utils.sizeof(<span class="hljs-string">&quot;ins&quot;</span>))));<br>    <span class="hljs-keyword">if</span> (!labelMatcher.group(<span class="hljs-number">2</span>).trim().isEmpty()) &#123;<br>          insLineno++;<br>    &#125;<br>    instructions.add(labelMatcher.group(<span class="hljs-number">2</span>));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    insLineno++;<br>    instructions.add(v);<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历所有的指令，对于符合label正则的，将<code>label的地址、label的行数、label的名字</code>存入labels变量中。在进行这几部预处理后，指令段进入逐行转译阶段，逐行阶段由parseOneLine方法处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Instruction <span class="hljs-title function_">parseOneLine</span><span class="hljs-params">(String asm, <span class="hljs-type">int</span> lineno)</span> &#123;<br>        <span class="hljs-comment">// 处理助记符</span><br>        <span class="hljs-type">Pattern</span> <span class="hljs-variable">pattern</span> <span class="hljs-operator">=</span> Pattern.compile(<span class="hljs-string">&quot;^\\s*(\\w+)\\s*(.*)&quot;</span>);<br>        <span class="hljs-type">Matcher</span> <span class="hljs-variable">matcher</span> <span class="hljs-operator">=</span> pattern.matcher(asm);<br>        <span class="hljs-keyword">if</span> (!matcher.matches()) &#123;<br>            System.out.print(<span class="hljs-string">&quot;\&quot;没有找到指令助记符，在代码第 &quot;</span> + lineno);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> matcher.group(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 检验助记符合法性</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">instructionIndex</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; minisysInstructions.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (minisysInstructions.get(i).getSymbol().equals(symbol)) &#123;<br>                instructionIndex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 单行汇编去空格</span><br>        asm = Utils.serialString(matcher.group(<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">// pc移进</span><br>        pc += Utils.sizeof(<span class="hljs-string">&quot;ins&quot;</span>);<br>        <span class="hljs-comment">// 开始组装Instruction对象</span><br>        <span class="hljs-type">Instruction</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> Instruction.newInstance(minisysInstructions.get(instructionIndex));<br>        res.setSrc(symbol+<span class="hljs-string">&quot; &quot;</span>+asm);<br>        <span class="hljs-keyword">for</span> (InstructionComponent component : res.getComponents()) &#123;<br>            <span class="hljs-keyword">if</span> (component.getVal().trim().isEmpty()) &#123;<br>                res.setComponent(component.getDesc(), component.toBinary(res.getInsPattern().matcher(asm)));<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如上图所示，即为parseOneLine的具体实现，函数首先使用正则表达式从<code>asm</code>字符串中提取助记符（指令的符号名称）。接下来，函数通过在<code>MinisysInstructions</code>数组中查找其索引来检查助记符的有效性。</p><p>然后，函数使用<code>serialString</code>函数从<code>asm</code>字符串中删除所有空格，并将程序计数器（<code>pc</code>）增加一个指令的大小。</p><p>接着，函数开始组装<code>Instruction</code>对象。它根据在<code>MinisysInstructions</code>数组中找到的指令创建<code>Instruction</code>类的新实例。函数然后遍历指令的每个组件。对于每个不是指令二进制中的<code>FIXED</code>的组件（即需要填充的变量），使用<code>setComponent</code>方法将组件从<code>toBinary</code>中获得的值设置为其二进制表示。</p><p>最后，函数返回组装的<code>Instruction</code>对象。需要注意的是该语句，也是Instruction的核心。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">component.toBinary(res.getInsPattern().matcher(asm))<br></code></pre></td></tr></table></figure><p>该语句中的toBinary即为上面InstructionComponent中提到的toBinary方法，其功能是生成二进制表示。具体实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toBinary</span><span class="hljs-params">(Matcher m)</span> &#123;<br>        <span class="hljs-keyword">if</span>(toBinary != <span class="hljs-literal">null</span> &amp;&amp; m.matches())<br>            <span class="hljs-keyword">return</span> toBinary.apply(m);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在Java中，调用java.util.function.Function变量时需要使用apply方法，这一机制允许对存储的参数执行预先定义的操作。举例来说，在处理add指令中，需要进行如下操作：对25位到21位的二进制进行转换，可以通过<code>m -&gt; Register.regToBin(m.group(2))</code>来实现（其中m表示正则匹配对象，通过m.group(2)获取第二个参数，并对其执行寄存器转二进制的操作）。</p><p>这种机制的优势在于，通过正则表达式可以灵活地获取指令的各个参数。通过调用apply方法，将正则匹配后的参数传递给函数变量，可以轻松实现二进制的转换。这使得指令的处理过程更加灵活、模块化，能够适应不同指令格式的需求。</p><h2 id="Linker-java-链接器的实现"><a href="#Linker-java-链接器的实现" class="headerlink" title="Linker.java 链接器的实现"></a>Linker.java 链接器的实现</h2><p>Minisys 体系使用哈佛结构，指令 MEM 有 64 KB，按字节编址。因此，其地址范围为 0x00000000 ~ 0x0000FFFF。指令 MEM 布局如下：</p><table><thead><tr><th>地址</th><th>作用</th></tr></thead><tbody><tr><td>0x00000000 ~ 0x00000499</td><td>BIOS 区域。大小为 500 H &#x3D; 1280 D Byte，最多存放 1280 &#x2F; 4 &#x3D; 320 条指令。</td></tr><tr><td>0x00000500 ~ 0x00005499</td><td>用户程序区域。大小为 5000 H &#x3D; 20480 D Byte，最多存放 20480 &#x2F; 4 &#x3D;  5120 条指令。</td></tr><tr><td>0x00005500 ~ 0x0000EFFF</td><td>空。</td></tr><tr><td>0x0000F000 ~ 0x0000F499</td><td>中断处理程序入口。大小为 500 H &#x3D; 1280 D Byte，最多存放 1280 &#x2F; 4 &#x3D; 320 条指令。</td></tr><tr><td>0x0000F500 ~ 0x0000FFFF</td><td>中断处理程序。大小为 B00 H &#x3D; 2816 D Byte，最多存放 2816 &#x2F; 4 &#x3D; 704 条指令<br />。</td></tr></tbody></table><p>通过前述计算，我们能够得知指令的最高限制和位置分布。在链接器中，通过countIns方法计算asm文件中的指令个数。如果计算得到的指令个数超过了最高限制，将触发错误处理。反之，若未超过限制，则通过添加nop（空指令）进行补充，以使指令数量达到相应的地址要求。实现大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// User App 0x00000500 ~ 0x00005499</span><br><span class="hljs-type">int</span> <span class="hljs-variable">userASMInsCount</span> <span class="hljs-operator">=</span> countIns(userASM);<br>assertLength(userASMInsCount, <span class="hljs-number">5120</span>, <span class="hljs-string">&quot;用户程序段过长。&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">userNopPadding</span> <span class="hljs-operator">=</span> <span class="hljs-number">5120</span> - userASMInsCount;<br><br>....其他区域代码<br><br><span class="hljs-comment">// User Application</span><br>allProgram.append(<span class="hljs-string">&quot;# ====== User Application START ======\n&quot;</span>);<br>allProgram.append(<span class="hljs-string">&quot;# User Application Length = &quot;</span>).append(userASMInsCount).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>allProgram.append(userASM).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>allProgram.append(<span class="hljs-string">&quot;# User Application Padding = &quot;</span>).append(userNopPadding).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>allProgram.append(<span class="hljs-string">&quot;nop\n&quot;</span>.repeat(userNopPadding));<br>allProgram.append(<span class="hljs-string">&quot;# ====== User Application END ======\n&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="Converter-java：Coe文件的生成"><a href="#Converter-java：Coe文件的生成" class="headerlink" title="Converter.java：Coe文件的生成"></a>Converter.java：Coe文件的生成</h2><p>对于指令段，由textsegToCoe方法生成。该方法中主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Instruction ins : textSeg.getIns()) &#123;<br>           <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>           <span class="hljs-keyword">for</span> (InstructionComponent comp : ins.getComponents()) &#123;<br>               buf.append(comp.getVal());<br>           &#125;<br>           coe.append(Utils.binToHex(buf.toString(), <span class="hljs-literal">false</span>)).append(<span class="hljs-string">&quot;,\n&quot;</span>);<br>           lineno++;<br>       &#125;<br></code></pre></td></tr></table></figure><p>该方法的主要操作就是将之前InstrumentComponent中toBinary方法得到的val进行合并生成二进制表示。</p><h1 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h1><ol><li><p>请在jar文件路径下，创建bios的文件，将src\snippet中3个asm文件放进bios中</p><ul><li>如果没有asm文件，无法使用链接，既无法加上 “-l” 参数。</li><li>可以使用自己的bios文件，但需要改成相应的名字。</li><li>src\snippet中3个文件分别用来：bios引导系统程序入口、interpret-entry中断程序的入口、interpret-handler中断程序处理 。</li></ul></li><li><p>jar的项目结构如下：</p></li></ol><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs delphi">jar文件路径<br>│  miniasm-java.jar<br>│<br>└─bios<br>        minisys-bios.<span class="hljs-keyword">asm</span><br>        minisys-<span class="hljs-keyword">interrupt</span>-entry.<span class="hljs-keyword">asm</span><br>        minisys-<span class="hljs-keyword">interrupt</span>-handler.<span class="hljs-keyword">asm</span><br></code></pre></td></tr></table></figure><ol start="3"><li>指令格式如下所示，其中 “-l” 为可选选项，表示是否链接。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ java -jar minisys-java.jar &lt;in_file&gt; &lt;out_dir&gt; -l<br></code></pre></td></tr></table></figure><p>&lt;in_file&gt; 表示输入的文件路径，&lt;out_dir&gt;表示输出文件路径，输出的文件如果没创建则会新建。如果输入的文件和jar在同一路径，则可以直接使用<code>$ java -jar minisys-java.jar in.asm out -l</code></p><p><code>in.asm</code>可替换自己的asm文件名字，输出的文件会保持在当前目录的out文件夹里面。也可以直接使用绝对路径。</p><h1 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-meta">.DATA</span> <span class="hljs-number">0x00001000</span><br><span class="hljs-keyword">buf: </span><span class="hljs-meta">.WORD</span> <span class="hljs-number">0x000000ff</span>,<span class="hljs-number">0x55005500</span><br><span class="hljs-keyword">buf2: </span>.<span class="hljs-keyword">byte </span><span class="hljs-number">1</span><br>      <span class="hljs-meta">.ascii</span> <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-meta">.TEXT</span> <span class="hljs-number">0x00003456</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">addi </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">zero</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">lw </span>   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">20</span>($<span class="hljs-built_in">t0</span>)<br>        <span class="hljs-keyword">addi </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">4</span><br>        <span class="hljs-keyword">lw </span>   $<span class="hljs-built_in">v1</span>, <span class="hljs-number">20</span>($<span class="hljs-built_in">t0</span>)<br>        <span class="hljs-keyword">add </span>  $<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">v0</span>, $<span class="hljs-built_in">v1</span><br>        <span class="hljs-keyword">addi </span> $<span class="hljs-built_in">t0</span>, $<span class="hljs-built_in">t0</span>, <span class="hljs-number">4</span><br>        <span class="hljs-keyword">sw </span>   $<span class="hljs-built_in">v0</span>, <span class="hljs-number">20</span>($<span class="hljs-built_in">t0</span>)<br>        <span class="hljs-keyword">j </span>    start<br>```<br></code></pre></td></tr></table></figure><p>输入数据如上，输出的解析结构如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">textSeg:</span>&#123;<br><span class="hljs-symbol">startAddr:</span><span class="hljs-number">13400</span>,<span class="hljs-keyword">Instruction:&#123;</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">zero</span>,<span class="hljs-number">0</span> Hex:<span class="hljs-number">20080000</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">v0</span>,<span class="hljs-number">20</span>($<span class="hljs-built_in">t0</span>) Hex:<span class="hljs-number">8</span>d020014<br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t0</span>,<span class="hljs-number">4</span> Hex:<span class="hljs-number">21080004</span><br><span class="hljs-keyword">lw </span>$<span class="hljs-built_in">v1</span>,<span class="hljs-number">20</span>($<span class="hljs-built_in">t0</span>) Hex:<span class="hljs-number">8</span>d030014<br><span class="hljs-keyword">add </span>$<span class="hljs-built_in">v0</span>,$<span class="hljs-built_in">v0</span>,$<span class="hljs-built_in">v1</span> Hex:<span class="hljs-number">00431020</span><br><span class="hljs-keyword">addi </span>$<span class="hljs-built_in">t0</span>,$<span class="hljs-built_in">t0</span>,<span class="hljs-number">4</span> Hex:<span class="hljs-number">21080004</span><br><span class="hljs-keyword">sw </span>$<span class="hljs-built_in">v0</span>,<span class="hljs-number">20</span>($<span class="hljs-built_in">t0</span>) Hex:ad020014<br><span class="hljs-keyword">j </span>start Hex:<span class="hljs-number">08000</span>d16<br>&#125;,<br><span class="hljs-symbol">Labels:</span>&#123;<br>start<br>&#125;<br>&#125;<br><span class="hljs-symbol">dataSeg:</span>&#123;<br><span class="hljs-symbol">startAddr:</span><span class="hljs-number">0x00001000</span>,vars:&#123;<br><span class="hljs-symbol">name:</span><span class="hljs-keyword">buf</span><span class="hljs-keyword">addr:4096</span>&#123;<br><span class="hljs-symbol">type:</span>wordval:<span class="hljs-number">0x000000ff</span><br><span class="hljs-symbol">type:</span>wordval:<span class="hljs-number">0x55005500</span><br>&#125;<br><span class="hljs-symbol">name:</span><span class="hljs-keyword">buf2</span><span class="hljs-keyword">addr:4104</span>&#123;<br><span class="hljs-symbol">type:</span><span class="hljs-keyword">byte</span>val:<span class="hljs-number">1</span><br><span class="hljs-symbol">type:</span>asciival:hello<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到dataSeg里面存储了startAddr数据以及vars，vars中存储了具体的变量type以及val。</p><p>对于textSeg里面也存储了startAddr，对于Instruction也成功转译为二进制。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/blog/2024/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/blog/2024/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>这是一篇测试文章</p><img src="/blog/2024/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="图片引用方法一"><img src="/blog/2024/01/08/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/image.png" class="" title="图片引用方法一"><p>————————————————</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
